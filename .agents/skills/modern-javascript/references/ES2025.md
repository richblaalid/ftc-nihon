# ES2025 Features

Set operations, iterator helpers, explicit resource management, Array.fromAsync, Error.isError, Promise.try, Float16, Intl.DurationFormat, import attributes, RegExp.escape, pattern modifiers, duplicate named capture groups.

## Set Methods

Mathematical set operations.

```javascript
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([3, 4, 5, 6]);

// Union: elements in either set
setA.union(setB);
// Set {1, 2, 3, 4, 5, 6}

// Intersection: elements in both sets
setA.intersection(setB);
// Set {3, 4}

// Difference: elements in A but not B
setA.difference(setB);
// Set {1, 2}

// Symmetric difference: elements in either but not both
setA.symmetricDifference(setB);
// Set {1, 2, 5, 6}

// Subset check
const setC = new Set([1, 2]);
setC.isSubsetOf(setA);      // true
setA.isSupersetOf(setC);    // true

// Disjoint check (no common elements)
const setD = new Set([7, 8]);
setA.isDisjointFrom(setD);  // true
```

**Practical example:**
```javascript
const userPermissions = new Set(['read', 'write']);
const requiredPermissions = new Set(['read', 'delete']);

// Check what's missing
const missing = requiredPermissions.difference(userPermissions);
// Set {'delete'}

// Check if has all required
const hasAll = requiredPermissions.isSubsetOf(userPermissions);
// false
```

## Iterator Helpers

Process iterators without converting to arrays.

```javascript
// Create iterator
const numbers = [1, 2, 3, 4, 5].values();

// map() on iterator
const doubled = numbers.map(n => n * 2);
// Iterator yielding 2, 4, 6, 8, 10

// filter() on iterator
const evens = [1, 2, 3, 4, 5].values().filter(n => n % 2 === 0);
// Iterator yielding 2, 4

// take() - limit results
const firstThree = [1, 2, 3, 4, 5].values().take(3);
// Iterator yielding 1, 2, 3

// drop() - skip results
const afterTwo = [1, 2, 3, 4, 5].values().drop(2);
// Iterator yielding 3, 4, 5

// flatMap()
const nested = [[1, 2], [3, 4]].values().flatMap(arr => arr);
// Iterator yielding 1, 2, 3, 4

// reduce()
const sum = [1, 2, 3, 4, 5].values().reduce((a, b) => a + b, 0);
// 15

// toArray() - convert to array
const arr = [1, 2, 3].values().map(n => n * 2).toArray();
// [2, 4, 6]

// forEach()
[1, 2, 3].values().forEach(n => console.log(n));

// some() / every()
[1, 2, 3].values().some(n => n > 2);   // true
[1, 2, 3].values().every(n => n > 0);  // true

// find()
[1, 2, 3, 4].values().find(n => n > 2);  // 3
```

**Lazy evaluation benefits:**
```javascript
// Process large datasets without loading all into memory
function* generateLargeDataset() {
  for (let i = 0; i < 1000000; i++) {
    yield { id: i, value: Math.random() };
  }
}

// Only processes 10 items, not all 1M
const firstTen = generateLargeDataset()
  .filter(item => item.value > 0.9)
  .take(10)
  .toArray();
```

## Iterator.from()

Create iterators from any iterable.

```javascript
// Convert iterable to iterator with helpers
const setIterator = Iterator.from(new Set([1, 2, 3]));

// Now has all iterator helper methods
setIterator
  .filter(n => n > 1)
  .map(n => n * 2)
  .toArray();
// [4, 6]

// Works with any iterable
const mapIter = Iterator.from(new Map([['a', 1], ['b', 2]]));
const stringIter = Iterator.from('hello');
```

## RegExp.escape()

Safely escape strings for use in regex.

```javascript
const userInput = 'price: $100 (USD)';

// ❌ Before: Manual escaping (error-prone)
const escaped = userInput.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

// ✅ After: Built-in escape
const escaped = RegExp.escape(userInput);
// 'price: \\$100 \\(USD\\)'

const pattern = new RegExp(escaped);
pattern.test('price: $100 (USD)');  // true
```

**Practical example: Safe search:**
```javascript
function createSearchPattern(searchTerm) {
  return new RegExp(RegExp.escape(searchTerm), 'gi');
}

const query = 'C++ (language)';
const pattern = createSearchPattern(query);
// Safely matches "C++ (language)" in text
```

## RegExp Pattern Modifiers (Inline Flags)

Apply flags to specific parts of a regex instead of the whole pattern.

```javascript
// Apply case-insensitivity only to part of pattern
const pattern = /^(?i:hello) world$/;

pattern.test('hello world');   // true
pattern.test('HELLO world');   // true
pattern.test('Hello World');   // false (World not modified)

// Multiple modifiers
const mixed = /(?i:abc)(?-i:DEF)/;
// abc is case-insensitive, DEF must be exact case

// Useful for partial matching
const filePattern = /(?i:readme)\.md$/;
filePattern.test('README.md');  // true
filePattern.test('ReadMe.md');  // true
filePattern.test('readme.MD');  // false (.md must be lowercase)
```

## Duplicate Named Capture Groups

Reuse capture group names in different alternatives.

```javascript
// ❌ Before: Each name must be unique
const datePattern = /(?<year>\d{4})-(?<month>\d{2})|(?<month2>\d{2})\/(?<year2>\d{4})/;

// ✅ Now: Same names allowed in different alternatives
const datePattern = /(?<year>\d{4})-(?<month>\d{2})|(?<month>\d{2})\/(?<year>\d{4})/;

// Both formats work with same group names
'2024-03-15'.match(datePattern).groups;
// { year: '2024', month: '03' }

'03/15/2024'.match(datePattern).groups;
// { year: '2024', month: '03' }  (same names!)
```

## Explicit Resource Management (`using`)

Automatic cleanup of resources like file handles, connections, and locks.

```javascript
// Synchronous disposal with `using`
{
  using file = openFile('data.txt');
  // Work with file...
} // file[Symbol.dispose]() called automatically

// Asynchronous disposal with `await using`
{
  await using db = await connectDatabase();
  await db.query('SELECT * FROM users');
} // db[Symbol.asyncDispose]() awaited automatically

// Creating disposable resources
class FileHandle {
  #handle;

  constructor(path) {
    this.#handle = fs.openSync(path);
  }

  read() { /* ... */ }

  [Symbol.dispose]() {
    fs.closeSync(this.#handle);
    console.log('File closed');
  }
}

// DisposableStack for multiple resources
{
  using stack = new DisposableStack();
  const file1 = stack.use(openFile('a.txt'));
  const file2 = stack.use(openFile('b.txt'));
  // Both disposed in reverse order when block exits
}

// AsyncDisposableStack for async cleanup
{
  await using stack = new AsyncDisposableStack();
  const conn1 = stack.use(await connect('db1'));
  const conn2 = stack.use(await connect('db2'));
}
```

**Key concepts:**
- `Symbol.dispose` - Sync cleanup method
- `Symbol.asyncDispose` - Async cleanup method
- `DisposableStack` - Aggregate multiple disposables
- `AsyncDisposableStack` - Async version
- `SuppressedError` - Wraps errors during disposal

## Array.fromAsync()

Create arrays from async iterables (async version of `Array.from`).

```javascript
// From async generator
async function* fetchPages() {
  yield await fetch('/page/1').then(r => r.json());
  yield await fetch('/page/2').then(r => r.json());
  yield await fetch('/page/3').then(r => r.json());
}

const pages = await Array.fromAsync(fetchPages());
// [page1Data, page2Data, page3Data]

// From any async iterable
const chunks = await Array.fromAsync(readableStream);

// With mapping function
const doubled = await Array.fromAsync(
  asyncGenerator(),
  async (x) => x * 2
);

// From sync iterable with promises
const results = await Array.fromAsync([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3)
]);
// [1, 2, 3]
```

**vs Promise.all:**
```javascript
// Promise.all - fetches ALL upfront, then awaits all
const results = await Promise.all(urls.map(u => fetch(u)));

// Array.fromAsync - processes lazily, one at a time
const results = await Array.fromAsync(asyncGenerator());
```

## Error.isError()

Reliably check if a value is an Error across realms (iframes, workers, vm).

```javascript
// Problem: instanceof fails across realms
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const err = new iframe.contentWindow.Error('oops');

err instanceof Error;      // false (different realm!)
Error.isError(err);        // true ✓

// Works for all Error types
Error.isError(new TypeError('bad'));      // true
Error.isError(new RangeError('oops'));    // true
Error.isError(new SyntaxError('fail'));   // true
Error.isError({ message: 'fake' });       // false
Error.isError(null);                       // false
```

## Promise.try()

Start a Promise chain that might throw.

```javascript
// ❌ Before: Wrap in Promise.resolve or async
const result = await Promise.resolve().then(() => {
  return riskyOperation();  // Might throw
});

// ✅ After: Direct wrapping
const result = await Promise.try(() => {
  return riskyOperation();  // Throws are caught
});

// Handles both sync and async
Promise.try(() => syncFunction())
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

## Import Attributes

Specify module type explicitly.

```javascript
// Import JSON
import config from './config.json' with { type: 'json' };

// Import CSS (when supported)
import styles from './styles.css' with { type: 'css' };

// Dynamic import with attributes
const data = await import('./data.json', { with: { type: 'json' } });
```

## Float16 Support

Half-precision floating point.

```javascript
// Float16Array
const f16 = new Float16Array([1.5, 2.5, 3.5]);

// Math.f16round()
Math.f16round(1.337);  // Rounds to float16 precision

// DataView methods
const buffer = new ArrayBuffer(2);
const view = new DataView(buffer);
view.setFloat16(0, 1.5);
view.getFloat16(0);  // 1.5
```

## Intl.DurationFormat

Format time durations with locale support.

```javascript
const duration = { hours: 1, minutes: 46, seconds: 40 };

// Different styles
new Intl.DurationFormat('en', { style: 'long' }).format(duration);
// "1 hour, 46 minutes, 40 seconds"

new Intl.DurationFormat('en', { style: 'short' }).format(duration);
// "1 hr, 46 min, 40 sec"

new Intl.DurationFormat('en', { style: 'narrow' }).format(duration);
// "1h 46m 40s"

new Intl.DurationFormat('en', { style: 'digital' }).format(duration);
// "1:46:40"

// Localized
new Intl.DurationFormat('fr', { style: 'long' }).format(duration);
// "1 heure, 46 minutes et 40 secondes"

new Intl.DurationFormat('de', { style: 'long' }).format(duration);
// "1 Stunde, 46 Minuten und 40 Sekunden"
```

## Browser/Node.js Support

| Feature | Chrome | Firefox | Safari | Node.js |
|---------|--------|---------|--------|---------|
| Set methods | 122+ | 127+ | 17+ | 22+ |
| Iterator helpers | 122+ | 131+ | 18+ | 22+ |
| Iterator.from | 122+ | 131+ | 18+ | 22+ |
| RegExp.escape | 136+ | - | - | 23+ |
| Explicit Resource Mgmt | 134+ | - | - | 22+ |
| Array.fromAsync | 121+ | 115+ | 16.4+ | 22+ |
| Error.isError | - | - | - | - |
| Promise.try | 128+ | 132+ | 18+ | 22+ |
| Float16 | 121+ | 129+ | - | 22+ |
| Intl.DurationFormat | 129+ | - | 16.4+ | - |

Check https://caniuse.com for current status.
