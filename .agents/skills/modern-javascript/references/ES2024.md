# ES2024 Features

Object.groupBy(), Map.groupBy(), Promise.withResolvers(), String.isWellFormed(), String.toWellFormed(), RegExp v flag (Unicode sets), resizable ArrayBuffers, Atomics.waitAsync().

## Object.groupBy() and Map.groupBy()

Group array elements by a key.

```javascript
const inventory = [
  { name: 'asparagus', type: 'vegetable', quantity: 5 },
  { name: 'banana', type: 'fruit', quantity: 0 },
  { name: 'goat', type: 'meat', quantity: 23 },
  { name: 'cherry', type: 'fruit', quantity: 5 },
  { name: 'fish', type: 'meat', quantity: 22 }
];

// Group by type
const byType = Object.groupBy(inventory, item => item.type);
/*
{
  vegetable: [{ name: 'asparagus', ... }],
  fruit: [{ name: 'banana', ... }, { name: 'cherry', ... }],
  meat: [{ name: 'goat', ... }, { name: 'fish', ... }]
}
*/

// Group by availability
const byAvailability = Object.groupBy(inventory, item =>
  item.quantity > 0 ? 'inStock' : 'outOfStock'
);

// Map.groupBy for object keys
const byTypeMap = Map.groupBy(inventory, item => item.type);
// Returns Map instead of plain object
```

**Migration from manual grouping:**
```javascript
// âŒ Before
const grouped = items.reduce((acc, item) => {
  const key = item.category;
  if (!acc[key]) acc[key] = [];
  acc[key].push(item);
  return acc;
}, {});

// âœ… After
const grouped = Object.groupBy(items, item => item.category);
```

**When to use Map.groupBy:**
```javascript
// Use Map.groupBy when keys are non-strings
const byDate = Map.groupBy(events, event => event.date);
// Keys are Date objects, which work better as Map keys

// Or when key order matters
const byPriority = Map.groupBy(tasks, task => task.priority);
// Map preserves insertion order
```

## Promise.withResolvers()

Create a Promise with externally accessible resolve/reject.

```javascript
// âŒ Before: Awkward closure pattern
let resolve, reject;
const promise = new Promise((res, rej) => {
  resolve = res;
  reject = rej;
});
// Use resolve/reject somewhere else
resolve('done');

// âœ… After: Clean destructuring
const { promise, resolve, reject } = Promise.withResolvers();
// Use anywhere
setTimeout(() => resolve('done'), 1000);
await promise;  // 'done'
```

**Practical example: Event-to-Promise:**
```javascript
function waitForEvent(element, eventName) {
  const { promise, resolve } = Promise.withResolvers();
  element.addEventListener(eventName, resolve, { once: true });
  return promise;
}

const button = document.querySelector('button');
await waitForEvent(button, 'click');
console.log('Button was clicked!');
```

**Practical example: Manual async control:**
```javascript
class AsyncQueue {
  #queue = [];
  #pending = null;

  async next() {
    if (this.#queue.length > 0) {
      return this.#queue.shift();
    }
    this.#pending = Promise.withResolvers();
    return this.#pending.promise;
  }

  push(item) {
    if (this.#pending) {
      this.#pending.resolve(item);
      this.#pending = null;
    } else {
      this.#queue.push(item);
    }
  }
}
```

## Well-Formed Unicode Strings

Check and fix malformed UTF-16 strings.

```javascript
// Check if string is well-formed
const valid = 'Hello ðŸ‘‹';
const invalid = 'Hi \uD800';  // Lone surrogate

valid.isWellFormed();    // true
invalid.isWellFormed();  // false

// Fix malformed strings
invalid.toWellFormed();  // 'Hi ï¿½' (replacement character)

// Use before encoding for URLs/APIs
function safeEncode(str) {
  return encodeURIComponent(str.toWellFormed());
}
```

## RegExp v Flag (Unicode Sets)

Enhanced unicode handling in regex.

```javascript
// Set operations in character classes
const emoji = /[\p{Emoji}--\p{ASCII}]/v;  // Emoji minus ASCII

// String properties
const greekLetters = /\p{Script=Greek}/v;

// Intersection
const pattern = /[[a-z]&&[^aeiou]]/v;  // Consonants only

// Nested character classes
const complex = /[[0-9]--[0-4]]/v;  // 5-9 only
```

## Resizable ArrayBuffers

```javascript
// Create resizable buffer
const buffer = new ArrayBuffer(1024, { maxByteLength: 4096 });

console.log(buffer.byteLength);     // 1024
console.log(buffer.maxByteLength);  // 4096
console.log(buffer.resizable);      // true

// Resize within bounds
buffer.resize(2048);
console.log(buffer.byteLength);     // 2048

// Transfer ownership
const newBuffer = buffer.transfer(512);
console.log(buffer.byteLength);      // 0 (detached)
console.log(newBuffer.byteLength);   // 512
```

## Atomics.waitAsync()

Asynchronous shared memory waiting.

```javascript
const sharedBuffer = new SharedArrayBuffer(4);
const sharedArray = new Int32Array(sharedBuffer);

// Async wait (doesn't block main thread)
const result = Atomics.waitAsync(sharedArray, 0, 0);

if (result.async) {
  result.value.then(status => {
    console.log('Woke up:', status);  // 'ok' or 'timed-out'
  });
}

// In another context/worker
Atomics.notify(sharedArray, 0);
```

## Browser/Node.js Support

| Feature | Chrome | Firefox | Safari | Node.js |
|---------|--------|---------|--------|---------|
| Object.groupBy | 117+ | 119+ | 17.4+ | 21+ |
| Promise.withResolvers | 119+ | 121+ | 17.4+ | 22+ |
| String.isWellFormed | 111+ | 119+ | 16.4+ | 20+ |
| RegExp v flag | 112+ | 116+ | 17+ | 20+ |
| Resizable ArrayBuffer | 111+ | 111+ | 16.4+ | 20+ |

Check https://caniuse.com for current status.
